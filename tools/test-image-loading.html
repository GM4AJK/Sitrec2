<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Loading Performance Test</title>
    <script src="https://cdn.jsdelivr.net/npm/ndarray@1.0.19/ndarray.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #666;
            margin-bottom: 20px;
            font-size: 14px;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }
        input[type="number"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            width: 150px;
        }
        .buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-primary {
            background: #007bff;
            color: white;
        }
        .btn-primary:hover:not(:disabled) {
            background: #0056b3;
        }
        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background: #545b62;
        }
        .results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .result-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .result-card h3 {
            margin: 0 0 15px 0;
            color: #333;
            border-bottom: 2px solid #007bff;
            padding-bottom: 10px;
        }
        .result-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #eee;
        }
        .result-item:last-child {
            border-bottom: none;
        }
        .result-label {
            color: #666;
            font-weight: 500;
        }
        .result-value {
            color: #333;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }
        .status {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #007bff;
        }
        .status.running {
            border-left-color: #ffc107;
            background: #fffbf0;
        }
        .status.complete {
            border-left-color: #28a745;
            background: #f0f8f5;
        }
        .status.error {
            border-left-color: #dc3545;
            background: #fdf8f8;
        }
        .progress-bar {
            width: 100%;
            height: 24px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-top: 10px;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #007bff, #0056b3);
            transition: width 0.1s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: 600;
        }
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .comparison-table th,
        .comparison-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        .comparison-table th {
            background: #007bff;
            color: white;
            font-weight: 600;
        }
        .comparison-table tr:last-child td {
            border-bottom: none;
        }
        .comparison-table tr:hover {
            background: #f9f9f9;
        }
        .winner {
            background: #d4edda !important;
            font-weight: 600;
        }
        .test-methods {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-methods h3 {
            margin-top: 0;
            color: #333;
        }
        .method-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        .method-item {
            padding: 10px;
            background: #f9f9f9;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .method-item label {
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: normal;
            cursor: pointer;
        }
        .method-item input[type="checkbox"] {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>üñºÔ∏è Image Loading Performance Test</h1>
    <p class="subtitle">Testing different approaches for loading and converting elevation tiles to ndarrays</p>

    <div class="controls">
        <div class="control-group">
            <label>Tile Grid Size (e.g., 10 = 10x10 = 100 tiles)</label>
            <input type="number" id="gridSize" value="10" min="1" max="20">
        </div>

        <div class="control-group">
            <label>Zoom Level</label>
            <input type="number" id="zoomLevel" value="10" min="0" max="18">
        </div>

        <div class="test-methods">
            <h3>Test Methods</h3>
            <div class="method-list" id="methodsList"></div>
        </div>

        <div class="buttons">
            <button class="btn-primary" id="runButton">‚ñ∂ Run Selected Tests</button>
            <button class="btn-secondary" id="resetButton">‚Üª Reset Results</button>
        </div>
    </div>

    <div class="status" id="status" style="display: none;"></div>

    <div id="resultsContainer"></div>

    <script>
        // Test Registry
        class TestRegistry {
            constructor() {
                this.tests = new Map();
                this.results = new Map();
            }

            register(name, fn, description) {
                this.tests.set(name, { fn, description });
            }

            getTests() {
                return this.tests;
            }

            setResult(name, result) {
                this.results.set(name, result);
            }

            getResults() {
                return this.results;
            }

            clearResults() {
                this.results.clear();
            }
        }

        const registry = new TestRegistry();

        // TEST 1: Original approach with Image() and canvas
        registry.register(
            'Original (Image + Canvas)',
            async function(tiles, options) {
                const results = [];
                let loaded = 0;

                return new Promise((resolve) => {
                    const processQueue = () => {
                        if (tiles.length === 0 && loaded === 0) {
                            resolve(results);
                            return;
                        }

                        while (loaded < 5 && tiles.length > 0) {
                            loaded++;
                            const url = tiles.shift();

                            const img = new Image();
                            img.crossOrigin = "anonymous";

                            img.onload = () => {
                                const canvas = document.createElement("canvas");
                                canvas.width = img.width;
                                canvas.height = img.height;
                                const context = canvas.getContext("2d");
                                context.drawImage(img, 0, 0);
                                const pixels = context.getImageData(0, 0, img.width, img.height);
                                const pixelArray = new Uint8Array(pixels.data);
                                const shape = [img.height, img.width, 4];
                                const stride = [4 * img.width, 4, 1];
                                results.push({ url, success: true, width: img.width, height: img.height });

                                loaded--;
                                processQueue();
                            };

                            img.onerror = () => {
                                results.push({ url, success: false, error: 'Load failed' });
                                loaded--;
                                processQueue();
                            };

                            img.src = url;
                        }
                    };

                    processQueue();
                });
            },
            'Original Image + Canvas approach'
        );

        // TEST 2: createImageBitmap approach
        registry.register(
            'createImageBitmap',
            async function(tiles, options) {
                const results = [];
                let loaded = 0;

                return new Promise((resolve) => {
                    const processQueue = async () => {
                        if (tiles.length === 0 && loaded === 0) {
                            resolve(results);
                            return;
                        }

                        while (loaded < 5 && tiles.length > 0) {
                            loaded++;
                            const url = tiles.shift();

                            try {
                                const response = await fetch(url);
                                const blob = await response.blob();
                                const bitmap = await createImageBitmap(blob);

                                const canvas = document.createElement("canvas");
                                canvas.width = bitmap.width;
                                canvas.height = bitmap.height;
                                const context = canvas.getContext("2d");
                                context.drawImage(bitmap, 0, 0);
                                const pixels = context.getImageData(0, 0, bitmap.width, bitmap.height);
                                const pixelArray = new Uint8Array(pixels.data);

                                results.push({ url, success: true, width: bitmap.width, height: bitmap.height });
                                bitmap.close();

                                loaded--;
                                processQueue();
                            } catch (err) {
                                results.push({ url, success: false, error: err.message });
                                loaded--;
                                processQueue();
                            }
                        }
                    };

                    processQueue();
                });
            },
            'Using createImageBitmap API (more efficient)'
        );

        // TEST 3: Fetch + directly to canvas (no Image object)
        registry.register(
            'Fetch + Direct Canvas',
            async function(tiles, options) {
                const results = [];
                let loaded = 0;

                return new Promise((resolve) => {
                    const processQueue = async () => {
                        if (tiles.length === 0 && loaded === 0) {
                            resolve(results);
                            return;
                        }

                        while (loaded < 5 && tiles.length > 0) {
                            loaded++;
                            const url = tiles.shift();

                            try {
                                const response = await fetch(url);
                                const blob = await response.blob();
                                const bitmap = await createImageBitmap(blob);

                                const canvas = document.createElement("canvas");
                                canvas.width = bitmap.width;
                                canvas.height = bitmap.height;
                                const context = canvas.getContext("2d", { willReadFrequently: true });
                                context.drawImage(bitmap, 0, 0);
                                const pixels = context.getImageData(0, 0, bitmap.width, bitmap.height);
                                const pixelArray = new Uint8Array(pixels.data);

                                results.push({ url, success: true, width: bitmap.width, height: bitmap.height });
                                bitmap.close();

                                loaded--;
                                processQueue();
                            } catch (err) {
                                results.push({ url, success: false, error: err.message });
                                loaded--;
                                processQueue();
                            }
                        }
                    };

                    processQueue();
                });
            },
            'Fetch + createImageBitmap with canvas hints'
        );

        // TEST 4: CPU-based PNG decoding (pure JavaScript, no GPU)
        registry.register(
            'CPU PNG Decoder (UPNG.js)',
            async function(tiles, options) {
                const results = [];
                let loaded = 0;

                return new Promise((resolve) => {
                    const processQueue = async () => {
                        if (tiles.length === 0 && loaded === 0) {
                            resolve(results);
                            return;
                        }

                        while (loaded < 5 && tiles.length > 0) {
                            loaded++;
                            const url = tiles.shift();

                            try {
                                const response = await fetch(url);
                                const arrayBuffer = await response.arrayBuffer();
                                
                                // Decode PNG using CPU (no canvas, no GPU)
                                const data = new Uint8Array(arrayBuffer);
                                const img = UPNG.decode(data);
                                
                                // Get raw pixel data
                                const pixelArray = UPNG.toRGBA8(img)[0];
                                
                                results.push({ 
                                    url, 
                                    success: true, 
                                    width: img[0], 
                                    height: img[1] 
                                });

                                loaded--;
                                processQueue();
                            } catch (err) {
                                results.push({ url, success: false, error: err.message });
                                loaded--;
                                processQueue();
                            }
                        }
                    };

                    processQueue();
                });
            },
            'CPU-based PNG decoding using UPNG.js (pure JavaScript, no GPU/Canvas)'
        );

        // Web Worker code as a string
        const workerCode = `
self.onmessage = async (event) => {
    const { url, id } = event.data;
    try {
        const response = await fetch(url);
        const blob = await response.blob();
        const bitmap = await createImageBitmap(blob);

        const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
        const context = canvas.getContext('2d', { willReadFrequently: true });
        context.drawImage(bitmap, 0, 0);

        self.postMessage({
            id,
            success: true,
            width: bitmap.width,
            height: bitmap.height,
            url
        });

        bitmap.close();
    } catch (err) {
        self.postMessage({
            id,
            success: false,
            error: err.message,
            url
        });
    }
};
        `;

        // Create blob URL for worker
        let workerBlobUrl = null;
        try {
            const workerBlob = new Blob([workerCode], { type: 'application/javascript' });
            workerBlobUrl = URL.createObjectURL(workerBlob);
        } catch (err) {
            console.warn('Could not create worker blob:', err);
        }

        // TEST 5: Web Worker (off-thread processing)
        registry.register(
            'Web Worker (Off-Thread)',
            async function(tiles, options) {
                if (!workerBlobUrl) {
                    throw new Error('Web Worker not available - try running via http://localhost instead of file://');
                }

                const worker = new Worker(workerBlobUrl);
                const results = [];
                let pending = 0;
                let nextId = 0;

                return new Promise((resolve, reject) => {
                    worker.onerror = (err) => {
                        worker.terminate();
                        reject(new Error(`Error in Web Worker: ${err.message}`));
                    };

                    worker.onmessage = (event) => {
                        const { id, success, url, width, height, error } = event.data;
                        results.push({ url, success, width, height, error });
                        pending--;

                        if (tiles.length === 0 && pending === 0) {
                            worker.terminate();
                            resolve(results);
                            return;
                        }

                        processQueue();
                    };

                    const processQueue = () => {
                        while (pending < 10 && tiles.length > 0) {
                            const url = tiles.shift();
                            pending++;
                            worker.postMessage({ url, id: nextId++ });
                        }
                    };

                    processQueue();
                });
            },
            'Web Worker for parallel off-thread processing'
        );

        // Utility functions
        function generateTileUrls(gridSize, zoomLevel) {
            const urls = [];
            const baseUrl = 'https://s3.amazonaws.com/elevation-tiles-prod/normal/';

            // Use a fixed center point and generate tiles around it
            const centerX = Math.floor(Math.pow(2, zoomLevel) / 2);
            const centerY = Math.floor(Math.pow(2, zoomLevel) / 2);

            for (let dx = 0; dx < gridSize; dx++) {
                for (let dy = 0; dy < gridSize; dy++) {
                    const x = centerX + dx - Math.floor(gridSize / 2);
                    const y = centerY + dy - Math.floor(gridSize / 2);
                    const url = `${baseUrl}${zoomLevel}/${x}/${y}.png`;
                    urls.push(url);
                }
            }
            return urls;
        }

        function updateStatus(message, type = 'running', progress = null) {
            const statusEl = document.getElementById('status');
            statusEl.style.display = 'block';
            statusEl.className = `status ${type}`;
            statusEl.innerHTML = message;

            if (progress !== null) {
                const progressHtml = `
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: ${progress}%">
                            ${Math.round(progress)}%
                        </div>
                    </div>
                `;
                statusEl.innerHTML += progressHtml;
            }
        }

        function renderResults(allResults) {
            const container = document.getElementById('resultsContainer');
            const tests = Array.from(allResults.entries());

            if (tests.length === 0) {
                container.innerHTML = '';
                return;
            }

            // Find fastest test
            const fastest = tests.reduce((a, b) => a[1].time < b[1].time ? a : b)[1].time;

            let html = '<div class="results">';

            // Individual result cards
            tests.forEach(([name, result]) => {
                const isFastest = result.time === fastest;
                html += `
                    <div class="result-card">
                        <h3>${name}</h3>
                        <div class="result-item">
                            <span class="result-label">Total Time:</span>
                            <span class="result-value">${result.time.toFixed(2)}ms</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">Avg Per Tile:</span>
                            <span class="result-value">${(result.time / result.totalTiles).toFixed(2)}ms</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">Tiles Loaded:</span>
                            <span class="result-value">${result.successful}/${result.totalTiles}</span>
                        </div>
                        <div class="result-item">
                            <span class="result-label">Success Rate:</span>
                            <span class="result-value">${((result.successful / result.totalTiles) * 100).toFixed(1)}%</span>
                        </div>
                        ${isFastest ? '<div class="result-item" style="color: #28a745; font-weight: bold;">‚≠ê FASTEST</div>' : ''}
                    </div>
                `;
            });

            html += '</div>';

            // Comparison table
            html += `
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Test Method</th>
                            <th>Total Time (ms)</th>
                            <th>Per Tile (ms)</th>
                            <th>Success Rate</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            tests.forEach(([name, result]) => {
                const isFastest = result.time === fastest;
                const rowClass = isFastest ? 'winner' : '';
                html += `
                    <tr class="${rowClass}">
                        <td><strong>${name}</strong></td>
                        <td>${result.time.toFixed(2)}</td>
                        <td>${(result.time / result.totalTiles).toFixed(2)}</td>
                        <td>${((result.successful / result.totalTiles) * 100).toFixed(1)}%</td>
                    </tr>
                `;
            });

            html += `
                    </tbody>
                </table>
            `;

            container.innerHTML = html;
        }

        function renderMethodsList() {
            const container = document.getElementById('methodsList');
            const tests = registry.getTests();

            let html = '';
            tests.forEach((test, name) => {
                html += `
                    <div class="method-item">
                        <label>
                            <input type="checkbox" class="test-checkbox" value="${name}" checked>
                            <strong>${name}</strong>
                            <br>
                            <small style="color: #666;">${test.description}</small>
                        </label>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        async function runTests() {
            const gridSize = parseInt(document.getElementById('gridSize').value);
            const zoomLevel = parseInt(document.getElementById('zoomLevel').value);
            const selectedCheckboxes = document.querySelectorAll('.test-checkbox:checked');
            const selectedTests = Array.from(selectedCheckboxes).map(cb => cb.value);

            if (selectedTests.length === 0) {
                alert('Please select at least one test method');
                return;
            }

            document.getElementById('runButton').disabled = true;

            try {
                const tileUrls = generateTileUrls(gridSize, zoomLevel);
                const totalTiles = tileUrls.length;

                updateStatus(`Preparing to test ${totalTiles} tiles...`);

                registry.clearResults();

                for (const testName of selectedTests) {
                    const test = registry.getTests().get(testName);
                    updateStatus(`Running: <strong>${testName}</strong> (${totalTiles} tiles)`, 'running', 0);

                    const tilesCopy = [...tileUrls];
                    const startTime = performance.now();

                    try {
                        const results = await test.fn(tilesCopy, { gridSize, zoomLevel });
                        const endTime = performance.now();

                        const successful = results.filter(r => r.success).length;
                        const time = endTime - startTime;

                        registry.setResult(testName, {
                            time,
                            successful,
                            totalTiles,
                            results
                        });

                        updateStatus(`‚úì Completed: <strong>${testName}</strong> (${time.toFixed(2)}ms)`, 'complete');
                    } catch (err) {
                        updateStatus(`‚úó Error in ${testName}: ${err.message}`, 'error');
                    }

                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                renderResults(registry.getResults());
                updateStatus('All tests completed!', 'complete');
            } finally {
                document.getElementById('runButton').disabled = false;
            }
        }

        // Event listeners
        document.getElementById('runButton').addEventListener('click', runTests);
        document.getElementById('resetButton').addEventListener('click', () => {
            registry.clearResults();
            document.getElementById('resultsContainer').innerHTML = '';
            document.getElementById('status').style.display = 'none';
        });

        // Initialize
        renderMethodsList();
    </script>
</body>
</html>