import {md5} from 'js-md5';
import {SITREC_CACHE, SITREC_SERVER} from "../src/configUtils";
import {GlobalDateTimeNode, NodeMan} from "../src/Globals";
import {EUSToLLA} from "../src/LLA-ECEF-ENU";

//////////////////////////////////////////////////////////////////////////////////////////////////////

//console.log("SETTING _configParams");
// note, don't use this _configParams in the code, use configParams from login.js
export const _configParams = {

    rehostRequiresLogin: true,

    // This is the default map type if none specificed in the Sit file
    // Use DOCKER_MAP_TYPE if building for Docker, otherwise use DEFAULT_MAP_TYPE
    defaultMapType: process.env.DOCKER_BUILD
        ? (process.env.DOCKER_MAP_TYPE ?? "debug")
        : (process.env.DEFAULT_MAP_TYPE ?? "debug"), //"NRL_WMTS",

    customMapSources: {

        mapbox: {
            name: "MapBox",
            mapURL: (z, x, y, layer) => {
                // direct URL to the MapBox tile, not via the cachemaps.php
                // this is the URL that is used by the MapBox GL JS library
                return `https://api.mapbox.com/v4/mapbox.${layer}/${z}/${x}/${y}@2x.jpg80?access_token=pk.eyJ1IjoibWlja3dlc3QiLCJhIjoiY21ianEydHIwMGliaTJrcHB4cDgzbGZuaSJ9.J7jU9B_pz4Mo723klYpywQ`
            },
            layers: {
                "satellite": {
                    type: "jpg", //not used here yet
                }
            },
            layer: "satellite",
            maxZoom: 18,
            supportsOceanSurface: true, // MapBox satellite imagery can have ocean surface overlay
        },

        mapboxProxied: {
            name: "MapBox (Legacy)",
            mapURL: (z, x, y, layer) => {
                // let's try get the md5 hash of the URL

                const url = `https://api.mapbox.com/v4/mapbox.${layer}/${z}/${x}/${y}@2x.jpg80`;
                const urlMD5 = md5(url);


                // This calculates the correct DIRECT URL for the cache
                // so we can try this first and if it fails, then try the server
                // this is much faster than trying the server first
                // we add "?prefetch=1" to the URL to ensure it's a different cached version
                // to the one that is returned from cachemaps.php
                // otherwise Cloudflare and others will think it's not there even after
                // cachemaps.php has cached it
                const url1 = SITREC_CACHE + urlMD5 + ".jpg" + "?prefetch=1";

                // and this the the request to the server to cache it
                // if url1 does not exist then try url2
                const url2 = SITREC_SERVER + "cachemaps.php?url=" +
                    encodeURIComponent(url)

                return[url1, url2];
            },



            layers: {
                "satellite": {
                    type: "jpg", //not used here yet
                }
            },
            layer: "satellite",
            maxZoom: 15,
            supportsOceanSurface: true, // MapBox legacy satellite imagery can have ocean surface overlay

        },
        osm: {
            name: "Open Streetmap",
            mapURL: (z,x,y) => {
                return SITREC_SERVER+"cachemaps.php?url=" + encodeURIComponent(`https://c.tile.openstreetmap.org/${z}/${x}/${y}.png`)
            },
            maxZoom: 17,
            supportsOceanSurface: true, // OpenStreetMap can have ocean surface overlay

        },
        maptiler: {
            name: "MapTiler",

            // TODO - layers NEED TO include more info, like
            // MinZoom, MaxZoom, image format (png, jpg, etc)
            // e.g. here basic-v2 is png, 0-22, etc.
            // but satellite-v2 is jpg, so we need to have the correct extension in the URL

            layers: {
                "satellite-v2": {
                    minZoom: 0,
                    maxZoom: 22,
                    type: "jpg",
                },
                "satellite-mediumres": {
                    minZoom: 0,
                    maxZoom: 22,
                    type: "jpg",
                },


            },

            mapURL: (z,x,y, layerName, layerType) => {
                return(`https://api.maptiler.com/tiles/${layerName}/${z}/${x}/${y}.${layerType}?key=${process.env.MAPTILER_KEY}`); // key is metabunk specific - replace with your own
            },
            maxZoom: 16,
            supportsOceanSurface: true, // MapTiler satellite imagery can have ocean surface overlay

        },
        eox: {
            name: "EOX",
            mapURL: (z,x,y) => {
                return SITREC_SERVER+"cachemaps.php?url=" + encodeURIComponent(`https://tiles.maps.eox.at/wmts?layer=s2cloudless_3857&style=default&tilematrixset=g&Service=WMTS&Request=GetTile&Version=1.0.0&Format=image%2Fjpeg&TileMatrix=${z}&TileCol=${x}&TileRow=${y}`)
            },
            maxZoom: 12,
            supportsOceanSurface: true, // EOX satellite imagery can have ocean surface overlay

        },

        // Try make this just use the base url https://geoint.nrlssc.org/nrltileserver/wms/category/Imagery
        // or perhaps just the capabilities URL?

        NRL_WMS: {
            name: "Naval Research Laboratory WMS",
            mapURL: function (z,x,y, layerName, layerType) {
                return this.mapProjectionTextures.wmsGetMapURLFromTile("https://geoint.nrlssc.org/nrltileserver/wms/category/Imagery?",layerName,z,x,y);
            },
            capabilities: "https://geoint.nrlssc.org/nrltileserver/wms/category/Imagery?REQUEST=GetCapabilities&SERVICE=WMS",
            layer: "ImageryMosaic",
            maxZoom: 12,
            supportsOceanSurface: true, // NRL WMS imagery can have ocean surface overlay

        },

        NRL_WMTS: {
            name: "Naval Research Laboratory WMS Tile",

            mapURL: function (z,x,y,  layerName, layerType) {
                return this.mapProjectionTextures.wmtsGetMapURLFromTile("https://geoint.nrlssc.org/nrltileserver/wmts",layerName,z,x,y);
            },
            capabilities: "https://geoint.nrlssc.org/nrltileserver/wmts?REQUEST=GetCapabilities&VERSION=1.0.0&SERVICE=WMTS",
            layer: "BlueMarble_AUTO",
            mapping: 4326,
            maxZoom: 12,
            supportsOceanSurface: true, // NRL WMTS imagery can have ocean surface overlay

        },

    },

    customElevationSources: {
        AWS_Terrarium: {
            name: "AWS Terrarium",
//            url: "https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.tif",
//            url: "https://s3.amazonaws.com/elevation-tiles-prod/terrarium",

            mapURL: (z,x,y) => {
                return `https://s3.amazonaws.com/elevation-tiles-prod/terrarium/${z}/${x}/${y}.png`
            },

            maxZoom: 15,
            minZoom: 0,
            tileSize: 256,
            attribution: "AWS Terrarium Elevation Data",
        },

        NationalMap: {
            name: "National Map 3DEP GeoTIFF",
            // here's a working example URL
            // https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer/exportImage?f=image&format=tiff&bbox=-118.5,33.3,-118.3,33.5&bboxSR=4326&imageSR=4326&size=500,500
            mapURL: function (z,x,y, layerName, layerType) {
                return this.mapProjectionElevation.getWMSGeoTIFFURLFromTile("https://elevation.nationalmap.gov/arcgis/rest/services/3DEPElevation/ImageServer/exportImage",z,x,y);
            },
            maxZoom: 14,
            minZoom: 0,
            tileSize: 256,
            attribution: "National Map 3DEP GeoTIFF",
            mapping: 4326,
        }

    },

    extraHelpLinks: {

        "Sitrec Helper Chatbot": "https://www.chatbase.co/chatbot-iframe/jm08ypN4zneL5S7wU2QOD",
        // "ADS-B Helper Chatbot": "https://www.chatbase.co/chatbot-iframe/xPKq8RfpIPtnNw_dptU4p",
        "ADSBExchange": "https://globe.adsbexchange.com/",
        "FlightAware": "https://flightaware.com/",
        "PlaneFinder": "https://planefinder.net/",
        "Astrometry.net Image Solver": "https://nova.astrometry.net/upload",
    },


    // list of functions that can be called from the help menu
    // function name, then menu text, then tooltip text
    // You can define your own here, or remove those tha are not needed
    extraHelpFunctions: {
        adsbReplay: [adsbReplay, "ADSB Replay for this time and location", "Generate a link to ADSB Exchange Replay"],
        googleMapsLink: [googleMapsLink, "Google Maps for this location", "Create a Google Maps link to the current location"],
        inTheSkyLink: [inTheSkyLink, "In-The-Sky for this time and location", "Create a In The Sky link to the current location"],
    }


};

// functions from the extraHelpFunctions above
// remove any that you don't want. Or add them here.
// they are added to the help menu in CustomSupport.js
function adsbReplay() {
    // get want a URL like this:
    // https://globe.adsbexchange.com/?replay=2025-07-02-20:31&lat=32.996&lon=-96.715&zoom=11.9
    // which matches the current camera position and date/time

    const date = GlobalDateTimeNode.frameToDate(par.frame);

    // check to see if it's withing 30 minutes of the current time
    // and if so, give an alert saying that's too soon for replay

    const now = new Date();
    const diffMinutes = Math.abs((now - date) / 60000); // difference in minutes
    if (diffMinutes < 30) {
        alert("ADSB Replay is not available for the last 30 minutes.\nPlease wait until the data is available.");
        return;
    }



    // get the current camera position from the lookCamera in Lat and Lon
    const lookCamera = NodeMan.get("lookCamera");
    const pos = lookCamera.p(par.frame);
    const LLA = EUSToLLA(pos);

    // get date and time from the current frame
    const dateString = date.toISOString().slice(0, 16).replace("T", "-");
    const lat = LLA.x.toFixed(3);
    const lon = LLA.y.toFixed(3);
    const zoom = 13; // a fixed zoom level for the replay
    const url = `https://globe.adsbexchange.com/?replay=${dateString}&lat=${lat}&lon=${lon}&zoom=${zoom}`;
    console.log("ADSB Replay URL: " + url);
    // just open it in a new tab
    window.open(url, "_blank");

}

function googleMapsLink() {
    // example:
    // https://www.google.com/maps/@40.6729927,-74.7598043,27767

    // get the current camera position from the lookCamera in Lat and Lon
    const lookCamera = NodeMan.get("lookCamera");
    const pos = lookCamera.p(par.frame);
    const LLA = EUSToLLA(pos);

    // like:
    // https://www.google.com/maps/place/40%C2%B040'22.8%22N+74%C2%B045'35.3%22W/@40.6728307,-74.794137,12543m/
    const url = `https://www.google.com/maps/place/${LLA.x.toFixed(6)},${LLA.y.toFixed(6)}/@${LLA.x.toFixed(6)},${LLA.y.toFixed(6)},30000m`;
    console.log("Google Maps URL: " + url);
    window.open(url, "_blank");

}

function inTheSkyLink() {
    // https://in-the-sky.org/satmap_worldmap.php?year=2025&month=7&day=9&hour=22&min=37&latitude=40&longitude=0&timezone=0
    // get the current camera position from the lookCamera in Lat and Lon
    const lookCamera = NodeMan.get("lookCamera");
    const pos = lookCamera.p(par.frame);
    const LLA = EUSToLLA(pos);
    // get the current date and time from the GlobalDateTimeNode
    const date = GlobalDateTimeNode.frameToDate(par.frame);
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth() + 1; // months are 0-indexed
    const day = date.getUTCDate();
    const hour = date.getUTCHours();
    const min = date.getUTCMinutes();
    const latitude = LLA.x.toFixed(6);
    const longitude = LLA.y.toFixed(6);
    const timezone = 0; // UTC
    const url = `https://in-the-sky.org/satmap_worldmap.php?year=${year}&month=${month}&day=${day}&hour=${hour}&min=${min}&latitude=${latitude}&longitude=${longitude}&timezone=${timezone}`;
    console.log("In The Sky URL: " + url);
    window.open(url, "_blank");

}

// given a lookup string, find the closest location [lat, lon]
// or null if not found
export async function customLocationFunction(lookupString) {
    try {
        const url = "https://nominatim.openstreetmap.org/search?format=json&limit=1&q=" + encodeURIComponent(lookupString);
        const response = await fetch(url);
        const data = await response.json();

        if (data.length > 0) {
            const item = data[0];
            return [parseFloat(item.lat), parseFloat(item.lon)];
        }
        return null;
    } catch (error) {
        console.error("Error fetching location: ", error);
        return null;
    }
}


// given a lat and lon, find the closest altitude at that point
// or 0 if unable
export async function customAltitudeFunction(lat, lon) {
    try {
        const altUrl = `https://api.open-meteo.com/v1/elevation?latitude=${lat}&longitude=${lon}`;
        const response = await fetch(altUrl);
        const altData = await response.json();

        if (altData.elevation !== undefined) {
            // add 2m to the elevation, as we want to be above ground
            return altData.elevation[0] + 2;
        }
        return 0;
    } catch (error) {
        console.error("Error fetching elevation: ", error);
        return 0;
    }
}

// to avoid compile warnings if you remove the above functions, uncomment these lines
// export let customLocationFunction;
// export let customAltitudeFunction;


////////////////////////////////////////////////
// / Gimbal, GoFast, flir1, agua, dume, video, hayle, 29palms, SWR, kml, kansas,
// aa2292, lakemichigan, chilean, porterville, folsomlake, n14aq, swr, swrcss
// modelinspector, custom, afr179
// This is the sitch that is loaded when running on local
// export const localSituation = "modelinspector";
export const localSituation = "custom";
//////////////////////////////////////////////