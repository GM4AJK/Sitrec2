const { merge } = require('webpack-merge');
const common = require('./webpack.common.js');
const path = require('path');
const fs = require('fs');
const CopyPlugin = require("copy-webpack-plugin");
const copyPatterns = require('./webpackCopyPatterns');

// Create a standalone build directory
const standalonePath = path.resolve(__dirname, 'dist-standalone');

// Custom plugin to create required directories
class CreateDirectoriesPlugin {
    apply(compiler) {
        compiler.hooks.afterEmit.tap('CreateDirectoriesPlugin', () => {
            const directories = [
                path.resolve(standalonePath, 'sitrec-upload'),
                path.resolve(standalonePath, 'u')
            ];
            
            directories.forEach(dir => {
                if (!fs.existsSync(dir)) {
                    fs.mkdirSync(dir, { recursive: true });
                    console.log(`Created directory: ${dir}`);
                }
            });
        });
    }
}

module.exports = merge(common, {
    mode: 'development',
    devtool: 'eval-source-map', // Better for debugging - faster rebuild, good source maps
    optimization: {
        minimize: false, // Don't minify for debugging
        // Disable splitChunks to prevent multiple compilations
        splitChunks: false,
    },
    output: {
        filename: '[name].bundle.js', // Remove hash for easier debugging
        path: standalonePath,
        clean: true,
        // Enable source map support
        devtoolModuleFilenameTemplate: 'webpack://[namespace]/[resource-path]?[loaders]',
    },
    plugins: [
        // Filter out the original CopyPlugin to avoid duplicates
        ...common.plugins.filter(plugin => plugin.constructor.name !== 'CopyPlugin'),
        new CopyPlugin({
            patterns: [
                ...copyPatterns, // Use the same patterns but they'll go to standalonePath
                {
                    from: path.resolve(__dirname, 'docs'),
                    to: path.resolve(standalonePath, 'docs'),
                    globOptions: {
                        ignore: ['**/*.md'], // Ignore Markdown files here
                    },
                },
            ],
        }),
        new CreateDirectoriesPlugin(),
        // Add CircularDependencyPlugin only here to avoid duplication
        (() => {
            let hasStarted = false;
            let hasEnded = false;
            
            return new (require('circular-dependency-plugin'))({
                exclude: /node_modules/,
                include: /src/,
                // `onStart` is called before the cycle detection starts
                onStart({ compilation }) {
                    if (!hasStarted) {
                        console.log('start detecting webpack modules cycles');
                        hasStarted = true;
                    }
                },
                // `onDetected` is called for each module that is cyclical
                onDetected({ module: webpackModuleRecord, paths, compilation }) {
                    //return;

                    const ignoreModules = ["mathjs"];
                    // return if any of the ignoreModules is a substring of any of the paths
                    if (paths.some(path => ignoreModules.some(ignoreModule => path.includes(ignoreModule)))) {
                        return;
                    }
                    // `paths` will be an Array of the relative module paths that make up the cycle
                    // `module` will be the module record generated by webpack that caused the cycle
                    compilation.errors.push(new Error(paths.join(' -> ')))
                },
                // `onEnd` is called before the cycle detection ends
                onEnd({ compilation }) {
                    if (!hasEnded) {
                        console.log('end detecting webpack modules cycles');
                        hasEnded = true;
                    }
                },
            });
        })(),
    ]
});